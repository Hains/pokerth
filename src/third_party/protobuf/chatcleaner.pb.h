// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chatcleaner.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chatcleaner_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chatcleaner_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chatcleaner_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chatcleaner_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_chatcleaner_2eproto;
class ChatCleanerMessage;
struct ChatCleanerMessageDefaultTypeInternal;
extern ChatCleanerMessageDefaultTypeInternal _ChatCleanerMessage_default_instance_;
class CleanerChatReplyMessage;
struct CleanerChatReplyMessageDefaultTypeInternal;
extern CleanerChatReplyMessageDefaultTypeInternal _CleanerChatReplyMessage_default_instance_;
class CleanerChatRequestMessage;
struct CleanerChatRequestMessageDefaultTypeInternal;
extern CleanerChatRequestMessageDefaultTypeInternal _CleanerChatRequestMessage_default_instance_;
class CleanerInitAckMessage;
struct CleanerInitAckMessageDefaultTypeInternal;
extern CleanerInitAckMessageDefaultTypeInternal _CleanerInitAckMessage_default_instance_;
class CleanerInitMessage;
struct CleanerInitMessageDefaultTypeInternal;
extern CleanerInitMessageDefaultTypeInternal _CleanerInitMessage_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ChatCleanerMessage* Arena::CreateMaybeMessage<::ChatCleanerMessage>(Arena*);
template<> ::CleanerChatReplyMessage* Arena::CreateMaybeMessage<::CleanerChatReplyMessage>(Arena*);
template<> ::CleanerChatRequestMessage* Arena::CreateMaybeMessage<::CleanerChatRequestMessage>(Arena*);
template<> ::CleanerInitAckMessage* Arena::CreateMaybeMessage<::CleanerInitAckMessage>(Arena*);
template<> ::CleanerInitMessage* Arena::CreateMaybeMessage<::CleanerInitMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum CleanerChatReplyMessage_CleanerActionType : int {
  CleanerChatReplyMessage_CleanerActionType_cleanerActionNone = 0,
  CleanerChatReplyMessage_CleanerActionType_cleanerActionWarning = 1,
  CleanerChatReplyMessage_CleanerActionType_cleanerActionKick = 2,
  CleanerChatReplyMessage_CleanerActionType_cleanerActionBan = 3,
  CleanerChatReplyMessage_CleanerActionType_cleanerActionMute = 4
};
bool CleanerChatReplyMessage_CleanerActionType_IsValid(int value);
constexpr CleanerChatReplyMessage_CleanerActionType CleanerChatReplyMessage_CleanerActionType_CleanerActionType_MIN = CleanerChatReplyMessage_CleanerActionType_cleanerActionNone;
constexpr CleanerChatReplyMessage_CleanerActionType CleanerChatReplyMessage_CleanerActionType_CleanerActionType_MAX = CleanerChatReplyMessage_CleanerActionType_cleanerActionMute;
constexpr int CleanerChatReplyMessage_CleanerActionType_CleanerActionType_ARRAYSIZE = CleanerChatReplyMessage_CleanerActionType_CleanerActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CleanerChatReplyMessage_CleanerActionType_descriptor();
template<typename T>
inline const std::string& CleanerChatReplyMessage_CleanerActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CleanerChatReplyMessage_CleanerActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CleanerChatReplyMessage_CleanerActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CleanerChatReplyMessage_CleanerActionType_descriptor(), enum_t_value);
}
inline bool CleanerChatReplyMessage_CleanerActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CleanerChatReplyMessage_CleanerActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CleanerChatReplyMessage_CleanerActionType>(
    CleanerChatReplyMessage_CleanerActionType_descriptor(), name, value);
}
enum ChatCleanerMessage_ChatCleanerMessageType : int {
  ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerInitMessage = 1,
  ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerInitAckMessage = 2,
  ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerChatRequestMessage = 3,
  ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerChatReplyMessage = 4
};
bool ChatCleanerMessage_ChatCleanerMessageType_IsValid(int value);
constexpr ChatCleanerMessage_ChatCleanerMessageType ChatCleanerMessage_ChatCleanerMessageType_ChatCleanerMessageType_MIN = ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerInitMessage;
constexpr ChatCleanerMessage_ChatCleanerMessageType ChatCleanerMessage_ChatCleanerMessageType_ChatCleanerMessageType_MAX = ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerChatReplyMessage;
constexpr int ChatCleanerMessage_ChatCleanerMessageType_ChatCleanerMessageType_ARRAYSIZE = ChatCleanerMessage_ChatCleanerMessageType_ChatCleanerMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChatCleanerMessage_ChatCleanerMessageType_descriptor();
template<typename T>
inline const std::string& ChatCleanerMessage_ChatCleanerMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatCleanerMessage_ChatCleanerMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatCleanerMessage_ChatCleanerMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChatCleanerMessage_ChatCleanerMessageType_descriptor(), enum_t_value);
}
inline bool ChatCleanerMessage_ChatCleanerMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatCleanerMessage_ChatCleanerMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChatCleanerMessage_ChatCleanerMessageType>(
    ChatCleanerMessage_ChatCleanerMessageType_descriptor(), name, value);
}
enum CleanerChatType : int {
  cleanerChatTypeLobby = 0,
  cleanerChatTypeGame = 1
};
bool CleanerChatType_IsValid(int value);
constexpr CleanerChatType CleanerChatType_MIN = cleanerChatTypeLobby;
constexpr CleanerChatType CleanerChatType_MAX = cleanerChatTypeGame;
constexpr int CleanerChatType_ARRAYSIZE = CleanerChatType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CleanerChatType_descriptor();
template<typename T>
inline const std::string& CleanerChatType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CleanerChatType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CleanerChatType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CleanerChatType_descriptor(), enum_t_value);
}
inline bool CleanerChatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CleanerChatType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CleanerChatType>(
    CleanerChatType_descriptor(), name, value);
}
// ===================================================================

class CleanerInitMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CleanerInitMessage) */ {
 public:
  inline CleanerInitMessage() : CleanerInitMessage(nullptr) {}
  ~CleanerInitMessage() override;
  explicit PROTOBUF_CONSTEXPR CleanerInitMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CleanerInitMessage(const CleanerInitMessage& from);
  CleanerInitMessage(CleanerInitMessage&& from) noexcept
    : CleanerInitMessage() {
    *this = ::std::move(from);
  }

  inline CleanerInitMessage& operator=(const CleanerInitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CleanerInitMessage& operator=(CleanerInitMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CleanerInitMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CleanerInitMessage* internal_default_instance() {
    return reinterpret_cast<const CleanerInitMessage*>(
               &_CleanerInitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CleanerInitMessage& a, CleanerInitMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CleanerInitMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CleanerInitMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CleanerInitMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CleanerInitMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CleanerInitMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CleanerInitMessage& from) {
    CleanerInitMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CleanerInitMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CleanerInitMessage";
  }
  protected:
  explicit CleanerInitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientSecretFieldNumber = 2,
    kRequestedVersionFieldNumber = 1,
  };
  // required string clientSecret = 2;
  bool has_clientsecret() const;
  private:
  bool _internal_has_clientsecret() const;
  public:
  void clear_clientsecret();
  const std::string& clientsecret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientsecret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientsecret();
  PROTOBUF_NODISCARD std::string* release_clientsecret();
  void set_allocated_clientsecret(std::string* clientsecret);
  private:
  const std::string& _internal_clientsecret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientsecret(const std::string& value);
  std::string* _internal_mutable_clientsecret();
  public:

  // required uint32 requestedVersion = 1;
  bool has_requestedversion() const;
  private:
  bool _internal_has_requestedversion() const;
  public:
  void clear_requestedversion();
  uint32_t requestedversion() const;
  void set_requestedversion(uint32_t value);
  private:
  uint32_t _internal_requestedversion() const;
  void _internal_set_requestedversion(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CleanerInitMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientsecret_;
    uint32_t requestedversion_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatcleaner_2eproto;
};
// -------------------------------------------------------------------

class CleanerInitAckMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CleanerInitAckMessage) */ {
 public:
  inline CleanerInitAckMessage() : CleanerInitAckMessage(nullptr) {}
  ~CleanerInitAckMessage() override;
  explicit PROTOBUF_CONSTEXPR CleanerInitAckMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CleanerInitAckMessage(const CleanerInitAckMessage& from);
  CleanerInitAckMessage(CleanerInitAckMessage&& from) noexcept
    : CleanerInitAckMessage() {
    *this = ::std::move(from);
  }

  inline CleanerInitAckMessage& operator=(const CleanerInitAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CleanerInitAckMessage& operator=(CleanerInitAckMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CleanerInitAckMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CleanerInitAckMessage* internal_default_instance() {
    return reinterpret_cast<const CleanerInitAckMessage*>(
               &_CleanerInitAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CleanerInitAckMessage& a, CleanerInitAckMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CleanerInitAckMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CleanerInitAckMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CleanerInitAckMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CleanerInitAckMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CleanerInitAckMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CleanerInitAckMessage& from) {
    CleanerInitAckMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CleanerInitAckMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CleanerInitAckMessage";
  }
  protected:
  explicit CleanerInitAckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerSecretFieldNumber = 2,
    kServerVersionFieldNumber = 1,
  };
  // required string serverSecret = 2;
  bool has_serversecret() const;
  private:
  bool _internal_has_serversecret() const;
  public:
  void clear_serversecret();
  const std::string& serversecret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serversecret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serversecret();
  PROTOBUF_NODISCARD std::string* release_serversecret();
  void set_allocated_serversecret(std::string* serversecret);
  private:
  const std::string& _internal_serversecret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serversecret(const std::string& value);
  std::string* _internal_mutable_serversecret();
  public:

  // required uint32 serverVersion = 1;
  bool has_serverversion() const;
  private:
  bool _internal_has_serverversion() const;
  public:
  void clear_serverversion();
  uint32_t serverversion() const;
  void set_serverversion(uint32_t value);
  private:
  uint32_t _internal_serverversion() const;
  void _internal_set_serverversion(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CleanerInitAckMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serversecret_;
    uint32_t serverversion_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatcleaner_2eproto;
};
// -------------------------------------------------------------------

class CleanerChatRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CleanerChatRequestMessage) */ {
 public:
  inline CleanerChatRequestMessage() : CleanerChatRequestMessage(nullptr) {}
  ~CleanerChatRequestMessage() override;
  explicit PROTOBUF_CONSTEXPR CleanerChatRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CleanerChatRequestMessage(const CleanerChatRequestMessage& from);
  CleanerChatRequestMessage(CleanerChatRequestMessage&& from) noexcept
    : CleanerChatRequestMessage() {
    *this = ::std::move(from);
  }

  inline CleanerChatRequestMessage& operator=(const CleanerChatRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CleanerChatRequestMessage& operator=(CleanerChatRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CleanerChatRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CleanerChatRequestMessage* internal_default_instance() {
    return reinterpret_cast<const CleanerChatRequestMessage*>(
               &_CleanerChatRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CleanerChatRequestMessage& a, CleanerChatRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CleanerChatRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CleanerChatRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CleanerChatRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CleanerChatRequestMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CleanerChatRequestMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CleanerChatRequestMessage& from) {
    CleanerChatRequestMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CleanerChatRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CleanerChatRequestMessage";
  }
  protected:
  explicit CleanerChatRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 5,
    kChatMessageFieldNumber = 6,
    kRequestIdFieldNumber = 1,
    kCleanerChatTypeFieldNumber = 2,
    kGameIdFieldNumber = 3,
    kPlayerIdFieldNumber = 4,
  };
  // required string playerName = 5;
  bool has_playername() const;
  private:
  bool _internal_has_playername() const;
  public:
  void clear_playername();
  const std::string& playername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playername();
  PROTOBUF_NODISCARD std::string* release_playername();
  void set_allocated_playername(std::string* playername);
  private:
  const std::string& _internal_playername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playername(const std::string& value);
  std::string* _internal_mutable_playername();
  public:

  // required string chatMessage = 6;
  bool has_chatmessage() const;
  private:
  bool _internal_has_chatmessage() const;
  public:
  void clear_chatmessage();
  const std::string& chatmessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chatmessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chatmessage();
  PROTOBUF_NODISCARD std::string* release_chatmessage();
  void set_allocated_chatmessage(std::string* chatmessage);
  private:
  const std::string& _internal_chatmessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chatmessage(const std::string& value);
  std::string* _internal_mutable_chatmessage();
  public:

  // required uint32 requestId = 1;
  bool has_requestid() const;
  private:
  bool _internal_has_requestid() const;
  public:
  void clear_requestid();
  uint32_t requestid() const;
  void set_requestid(uint32_t value);
  private:
  uint32_t _internal_requestid() const;
  void _internal_set_requestid(uint32_t value);
  public:

  // required .CleanerChatType cleanerChatType = 2;
  bool has_cleanerchattype() const;
  private:
  bool _internal_has_cleanerchattype() const;
  public:
  void clear_cleanerchattype();
  ::CleanerChatType cleanerchattype() const;
  void set_cleanerchattype(::CleanerChatType value);
  private:
  ::CleanerChatType _internal_cleanerchattype() const;
  void _internal_set_cleanerchattype(::CleanerChatType value);
  public:

  // optional uint32 gameId = 3 [default = 0];
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 4;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CleanerChatRequestMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chatmessage_;
    uint32_t requestid_;
    int cleanerchattype_;
    uint32_t gameid_;
    uint32_t playerid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatcleaner_2eproto;
};
// -------------------------------------------------------------------

class CleanerChatReplyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CleanerChatReplyMessage) */ {
 public:
  inline CleanerChatReplyMessage() : CleanerChatReplyMessage(nullptr) {}
  ~CleanerChatReplyMessage() override;
  explicit PROTOBUF_CONSTEXPR CleanerChatReplyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CleanerChatReplyMessage(const CleanerChatReplyMessage& from);
  CleanerChatReplyMessage(CleanerChatReplyMessage&& from) noexcept
    : CleanerChatReplyMessage() {
    *this = ::std::move(from);
  }

  inline CleanerChatReplyMessage& operator=(const CleanerChatReplyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CleanerChatReplyMessage& operator=(CleanerChatReplyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CleanerChatReplyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CleanerChatReplyMessage* internal_default_instance() {
    return reinterpret_cast<const CleanerChatReplyMessage*>(
               &_CleanerChatReplyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CleanerChatReplyMessage& a, CleanerChatReplyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CleanerChatReplyMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CleanerChatReplyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CleanerChatReplyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CleanerChatReplyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CleanerChatReplyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CleanerChatReplyMessage& from) {
    CleanerChatReplyMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CleanerChatReplyMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CleanerChatReplyMessage";
  }
  protected:
  explicit CleanerChatReplyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CleanerChatReplyMessage_CleanerActionType CleanerActionType;
  static constexpr CleanerActionType cleanerActionNone =
    CleanerChatReplyMessage_CleanerActionType_cleanerActionNone;
  static constexpr CleanerActionType cleanerActionWarning =
    CleanerChatReplyMessage_CleanerActionType_cleanerActionWarning;
  static constexpr CleanerActionType cleanerActionKick =
    CleanerChatReplyMessage_CleanerActionType_cleanerActionKick;
  static constexpr CleanerActionType cleanerActionBan =
    CleanerChatReplyMessage_CleanerActionType_cleanerActionBan;
  static constexpr CleanerActionType cleanerActionMute =
    CleanerChatReplyMessage_CleanerActionType_cleanerActionMute;
  static inline bool CleanerActionType_IsValid(int value) {
    return CleanerChatReplyMessage_CleanerActionType_IsValid(value);
  }
  static constexpr CleanerActionType CleanerActionType_MIN =
    CleanerChatReplyMessage_CleanerActionType_CleanerActionType_MIN;
  static constexpr CleanerActionType CleanerActionType_MAX =
    CleanerChatReplyMessage_CleanerActionType_CleanerActionType_MAX;
  static constexpr int CleanerActionType_ARRAYSIZE =
    CleanerChatReplyMessage_CleanerActionType_CleanerActionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CleanerActionType_descriptor() {
    return CleanerChatReplyMessage_CleanerActionType_descriptor();
  }
  template<typename T>
  static inline const std::string& CleanerActionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CleanerActionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CleanerActionType_Name.");
    return CleanerChatReplyMessage_CleanerActionType_Name(enum_t_value);
  }
  static inline bool CleanerActionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CleanerActionType* value) {
    return CleanerChatReplyMessage_CleanerActionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCleanerTextFieldNumber = 6,
    kRequestIdFieldNumber = 1,
    kCleanerChatTypeFieldNumber = 2,
    kGameIdFieldNumber = 3,
    kPlayerIdFieldNumber = 4,
    kCleanerActionTypeFieldNumber = 5,
  };
  // optional string cleanerText = 6 [default = ""];
  bool has_cleanertext() const;
  private:
  bool _internal_has_cleanertext() const;
  public:
  void clear_cleanertext();
  const std::string& cleanertext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cleanertext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cleanertext();
  PROTOBUF_NODISCARD std::string* release_cleanertext();
  void set_allocated_cleanertext(std::string* cleanertext);
  private:
  const std::string& _internal_cleanertext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cleanertext(const std::string& value);
  std::string* _internal_mutable_cleanertext();
  public:

  // required uint32 requestId = 1;
  bool has_requestid() const;
  private:
  bool _internal_has_requestid() const;
  public:
  void clear_requestid();
  uint32_t requestid() const;
  void set_requestid(uint32_t value);
  private:
  uint32_t _internal_requestid() const;
  void _internal_set_requestid(uint32_t value);
  public:

  // required .CleanerChatType cleanerChatType = 2;
  bool has_cleanerchattype() const;
  private:
  bool _internal_has_cleanerchattype() const;
  public:
  void clear_cleanerchattype();
  ::CleanerChatType cleanerchattype() const;
  void set_cleanerchattype(::CleanerChatType value);
  private:
  ::CleanerChatType _internal_cleanerchattype() const;
  void _internal_set_cleanerchattype(::CleanerChatType value);
  public:

  // optional uint32 gameId = 3 [default = 0];
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // required uint32 playerId = 4;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // required .CleanerChatReplyMessage.CleanerActionType cleanerActionType = 5;
  bool has_cleaneractiontype() const;
  private:
  bool _internal_has_cleaneractiontype() const;
  public:
  void clear_cleaneractiontype();
  ::CleanerChatReplyMessage_CleanerActionType cleaneractiontype() const;
  void set_cleaneractiontype(::CleanerChatReplyMessage_CleanerActionType value);
  private:
  ::CleanerChatReplyMessage_CleanerActionType _internal_cleaneractiontype() const;
  void _internal_set_cleaneractiontype(::CleanerChatReplyMessage_CleanerActionType value);
  public:

  // @@protoc_insertion_point(class_scope:CleanerChatReplyMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cleanertext_;
    uint32_t requestid_;
    int cleanerchattype_;
    uint32_t gameid_;
    uint32_t playerid_;
    int cleaneractiontype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatcleaner_2eproto;
};
// -------------------------------------------------------------------

class ChatCleanerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChatCleanerMessage) */ {
 public:
  inline ChatCleanerMessage() : ChatCleanerMessage(nullptr) {}
  ~ChatCleanerMessage() override;
  explicit PROTOBUF_CONSTEXPR ChatCleanerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatCleanerMessage(const ChatCleanerMessage& from);
  ChatCleanerMessage(ChatCleanerMessage&& from) noexcept
    : ChatCleanerMessage() {
    *this = ::std::move(from);
  }

  inline ChatCleanerMessage& operator=(const ChatCleanerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatCleanerMessage& operator=(ChatCleanerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatCleanerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatCleanerMessage* internal_default_instance() {
    return reinterpret_cast<const ChatCleanerMessage*>(
               &_ChatCleanerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ChatCleanerMessage& a, ChatCleanerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatCleanerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatCleanerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatCleanerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatCleanerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatCleanerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatCleanerMessage& from) {
    ChatCleanerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatCleanerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChatCleanerMessage";
  }
  protected:
  explicit ChatCleanerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChatCleanerMessage_ChatCleanerMessageType ChatCleanerMessageType;
  static constexpr ChatCleanerMessageType Type_CleanerInitMessage =
    ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerInitMessage;
  static constexpr ChatCleanerMessageType Type_CleanerInitAckMessage =
    ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerInitAckMessage;
  static constexpr ChatCleanerMessageType Type_CleanerChatRequestMessage =
    ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerChatRequestMessage;
  static constexpr ChatCleanerMessageType Type_CleanerChatReplyMessage =
    ChatCleanerMessage_ChatCleanerMessageType_Type_CleanerChatReplyMessage;
  static inline bool ChatCleanerMessageType_IsValid(int value) {
    return ChatCleanerMessage_ChatCleanerMessageType_IsValid(value);
  }
  static constexpr ChatCleanerMessageType ChatCleanerMessageType_MIN =
    ChatCleanerMessage_ChatCleanerMessageType_ChatCleanerMessageType_MIN;
  static constexpr ChatCleanerMessageType ChatCleanerMessageType_MAX =
    ChatCleanerMessage_ChatCleanerMessageType_ChatCleanerMessageType_MAX;
  static constexpr int ChatCleanerMessageType_ARRAYSIZE =
    ChatCleanerMessage_ChatCleanerMessageType_ChatCleanerMessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ChatCleanerMessageType_descriptor() {
    return ChatCleanerMessage_ChatCleanerMessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& ChatCleanerMessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ChatCleanerMessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ChatCleanerMessageType_Name.");
    return ChatCleanerMessage_ChatCleanerMessageType_Name(enum_t_value);
  }
  static inline bool ChatCleanerMessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ChatCleanerMessageType* value) {
    return ChatCleanerMessage_ChatCleanerMessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCleanerInitMessageFieldNumber = 2,
    kCleanerInitAckMessageFieldNumber = 3,
    kCleanerChatRequestMessageFieldNumber = 4,
    kCleanerChatReplyMessageFieldNumber = 5,
    kMessageTypeFieldNumber = 1,
  };
  // optional .CleanerInitMessage cleanerInitMessage = 2;
  bool has_cleanerinitmessage() const;
  private:
  bool _internal_has_cleanerinitmessage() const;
  public:
  void clear_cleanerinitmessage();
  const ::CleanerInitMessage& cleanerinitmessage() const;
  PROTOBUF_NODISCARD ::CleanerInitMessage* release_cleanerinitmessage();
  ::CleanerInitMessage* mutable_cleanerinitmessage();
  void set_allocated_cleanerinitmessage(::CleanerInitMessage* cleanerinitmessage);
  private:
  const ::CleanerInitMessage& _internal_cleanerinitmessage() const;
  ::CleanerInitMessage* _internal_mutable_cleanerinitmessage();
  public:
  void unsafe_arena_set_allocated_cleanerinitmessage(
      ::CleanerInitMessage* cleanerinitmessage);
  ::CleanerInitMessage* unsafe_arena_release_cleanerinitmessage();

  // optional .CleanerInitAckMessage cleanerInitAckMessage = 3;
  bool has_cleanerinitackmessage() const;
  private:
  bool _internal_has_cleanerinitackmessage() const;
  public:
  void clear_cleanerinitackmessage();
  const ::CleanerInitAckMessage& cleanerinitackmessage() const;
  PROTOBUF_NODISCARD ::CleanerInitAckMessage* release_cleanerinitackmessage();
  ::CleanerInitAckMessage* mutable_cleanerinitackmessage();
  void set_allocated_cleanerinitackmessage(::CleanerInitAckMessage* cleanerinitackmessage);
  private:
  const ::CleanerInitAckMessage& _internal_cleanerinitackmessage() const;
  ::CleanerInitAckMessage* _internal_mutable_cleanerinitackmessage();
  public:
  void unsafe_arena_set_allocated_cleanerinitackmessage(
      ::CleanerInitAckMessage* cleanerinitackmessage);
  ::CleanerInitAckMessage* unsafe_arena_release_cleanerinitackmessage();

  // optional .CleanerChatRequestMessage cleanerChatRequestMessage = 4;
  bool has_cleanerchatrequestmessage() const;
  private:
  bool _internal_has_cleanerchatrequestmessage() const;
  public:
  void clear_cleanerchatrequestmessage();
  const ::CleanerChatRequestMessage& cleanerchatrequestmessage() const;
  PROTOBUF_NODISCARD ::CleanerChatRequestMessage* release_cleanerchatrequestmessage();
  ::CleanerChatRequestMessage* mutable_cleanerchatrequestmessage();
  void set_allocated_cleanerchatrequestmessage(::CleanerChatRequestMessage* cleanerchatrequestmessage);
  private:
  const ::CleanerChatRequestMessage& _internal_cleanerchatrequestmessage() const;
  ::CleanerChatRequestMessage* _internal_mutable_cleanerchatrequestmessage();
  public:
  void unsafe_arena_set_allocated_cleanerchatrequestmessage(
      ::CleanerChatRequestMessage* cleanerchatrequestmessage);
  ::CleanerChatRequestMessage* unsafe_arena_release_cleanerchatrequestmessage();

  // optional .CleanerChatReplyMessage cleanerChatReplyMessage = 5;
  bool has_cleanerchatreplymessage() const;
  private:
  bool _internal_has_cleanerchatreplymessage() const;
  public:
  void clear_cleanerchatreplymessage();
  const ::CleanerChatReplyMessage& cleanerchatreplymessage() const;
  PROTOBUF_NODISCARD ::CleanerChatReplyMessage* release_cleanerchatreplymessage();
  ::CleanerChatReplyMessage* mutable_cleanerchatreplymessage();
  void set_allocated_cleanerchatreplymessage(::CleanerChatReplyMessage* cleanerchatreplymessage);
  private:
  const ::CleanerChatReplyMessage& _internal_cleanerchatreplymessage() const;
  ::CleanerChatReplyMessage* _internal_mutable_cleanerchatreplymessage();
  public:
  void unsafe_arena_set_allocated_cleanerchatreplymessage(
      ::CleanerChatReplyMessage* cleanerchatreplymessage);
  ::CleanerChatReplyMessage* unsafe_arena_release_cleanerchatreplymessage();

  // required .ChatCleanerMessage.ChatCleanerMessageType messageType = 1;
  bool has_messagetype() const;
  private:
  bool _internal_has_messagetype() const;
  public:
  void clear_messagetype();
  ::ChatCleanerMessage_ChatCleanerMessageType messagetype() const;
  void set_messagetype(::ChatCleanerMessage_ChatCleanerMessageType value);
  private:
  ::ChatCleanerMessage_ChatCleanerMessageType _internal_messagetype() const;
  void _internal_set_messagetype(::ChatCleanerMessage_ChatCleanerMessageType value);
  public:

  // @@protoc_insertion_point(class_scope:ChatCleanerMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CleanerInitMessage* cleanerinitmessage_;
    ::CleanerInitAckMessage* cleanerinitackmessage_;
    ::CleanerChatRequestMessage* cleanerchatrequestmessage_;
    ::CleanerChatReplyMessage* cleanerchatreplymessage_;
    int messagetype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatcleaner_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CleanerInitMessage

// required uint32 requestedVersion = 1;
inline bool CleanerInitMessage::_internal_has_requestedversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CleanerInitMessage::has_requestedversion() const {
  return _internal_has_requestedversion();
}
inline void CleanerInitMessage::clear_requestedversion() {
  _impl_.requestedversion_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CleanerInitMessage::_internal_requestedversion() const {
  return _impl_.requestedversion_;
}
inline uint32_t CleanerInitMessage::requestedversion() const {
  // @@protoc_insertion_point(field_get:CleanerInitMessage.requestedVersion)
  return _internal_requestedversion();
}
inline void CleanerInitMessage::_internal_set_requestedversion(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.requestedversion_ = value;
}
inline void CleanerInitMessage::set_requestedversion(uint32_t value) {
  _internal_set_requestedversion(value);
  // @@protoc_insertion_point(field_set:CleanerInitMessage.requestedVersion)
}

// required string clientSecret = 2;
inline bool CleanerInitMessage::_internal_has_clientsecret() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CleanerInitMessage::has_clientsecret() const {
  return _internal_has_clientsecret();
}
inline void CleanerInitMessage::clear_clientsecret() {
  _impl_.clientsecret_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CleanerInitMessage::clientsecret() const {
  // @@protoc_insertion_point(field_get:CleanerInitMessage.clientSecret)
  return _internal_clientsecret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CleanerInitMessage::set_clientsecret(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.clientsecret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CleanerInitMessage.clientSecret)
}
inline std::string* CleanerInitMessage::mutable_clientsecret() {
  std::string* _s = _internal_mutable_clientsecret();
  // @@protoc_insertion_point(field_mutable:CleanerInitMessage.clientSecret)
  return _s;
}
inline const std::string& CleanerInitMessage::_internal_clientsecret() const {
  return _impl_.clientsecret_.Get();
}
inline void CleanerInitMessage::_internal_set_clientsecret(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.clientsecret_.Set(value, GetArenaForAllocation());
}
inline std::string* CleanerInitMessage::_internal_mutable_clientsecret() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.clientsecret_.Mutable(GetArenaForAllocation());
}
inline std::string* CleanerInitMessage::release_clientsecret() {
  // @@protoc_insertion_point(field_release:CleanerInitMessage.clientSecret)
  if (!_internal_has_clientsecret()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.clientsecret_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientsecret_.IsDefault()) {
    _impl_.clientsecret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CleanerInitMessage::set_allocated_clientsecret(std::string* clientsecret) {
  if (clientsecret != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.clientsecret_.SetAllocated(clientsecret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientsecret_.IsDefault()) {
    _impl_.clientsecret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CleanerInitMessage.clientSecret)
}

// -------------------------------------------------------------------

// CleanerInitAckMessage

// required uint32 serverVersion = 1;
inline bool CleanerInitAckMessage::_internal_has_serverversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CleanerInitAckMessage::has_serverversion() const {
  return _internal_has_serverversion();
}
inline void CleanerInitAckMessage::clear_serverversion() {
  _impl_.serverversion_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CleanerInitAckMessage::_internal_serverversion() const {
  return _impl_.serverversion_;
}
inline uint32_t CleanerInitAckMessage::serverversion() const {
  // @@protoc_insertion_point(field_get:CleanerInitAckMessage.serverVersion)
  return _internal_serverversion();
}
inline void CleanerInitAckMessage::_internal_set_serverversion(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.serverversion_ = value;
}
inline void CleanerInitAckMessage::set_serverversion(uint32_t value) {
  _internal_set_serverversion(value);
  // @@protoc_insertion_point(field_set:CleanerInitAckMessage.serverVersion)
}

// required string serverSecret = 2;
inline bool CleanerInitAckMessage::_internal_has_serversecret() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CleanerInitAckMessage::has_serversecret() const {
  return _internal_has_serversecret();
}
inline void CleanerInitAckMessage::clear_serversecret() {
  _impl_.serversecret_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CleanerInitAckMessage::serversecret() const {
  // @@protoc_insertion_point(field_get:CleanerInitAckMessage.serverSecret)
  return _internal_serversecret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CleanerInitAckMessage::set_serversecret(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.serversecret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CleanerInitAckMessage.serverSecret)
}
inline std::string* CleanerInitAckMessage::mutable_serversecret() {
  std::string* _s = _internal_mutable_serversecret();
  // @@protoc_insertion_point(field_mutable:CleanerInitAckMessage.serverSecret)
  return _s;
}
inline const std::string& CleanerInitAckMessage::_internal_serversecret() const {
  return _impl_.serversecret_.Get();
}
inline void CleanerInitAckMessage::_internal_set_serversecret(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.serversecret_.Set(value, GetArenaForAllocation());
}
inline std::string* CleanerInitAckMessage::_internal_mutable_serversecret() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.serversecret_.Mutable(GetArenaForAllocation());
}
inline std::string* CleanerInitAckMessage::release_serversecret() {
  // @@protoc_insertion_point(field_release:CleanerInitAckMessage.serverSecret)
  if (!_internal_has_serversecret()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.serversecret_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serversecret_.IsDefault()) {
    _impl_.serversecret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CleanerInitAckMessage::set_allocated_serversecret(std::string* serversecret) {
  if (serversecret != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.serversecret_.SetAllocated(serversecret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serversecret_.IsDefault()) {
    _impl_.serversecret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CleanerInitAckMessage.serverSecret)
}

// -------------------------------------------------------------------

// CleanerChatRequestMessage

// required uint32 requestId = 1;
inline bool CleanerChatRequestMessage::_internal_has_requestid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CleanerChatRequestMessage::has_requestid() const {
  return _internal_has_requestid();
}
inline void CleanerChatRequestMessage::clear_requestid() {
  _impl_.requestid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CleanerChatRequestMessage::_internal_requestid() const {
  return _impl_.requestid_;
}
inline uint32_t CleanerChatRequestMessage::requestid() const {
  // @@protoc_insertion_point(field_get:CleanerChatRequestMessage.requestId)
  return _internal_requestid();
}
inline void CleanerChatRequestMessage::_internal_set_requestid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.requestid_ = value;
}
inline void CleanerChatRequestMessage::set_requestid(uint32_t value) {
  _internal_set_requestid(value);
  // @@protoc_insertion_point(field_set:CleanerChatRequestMessage.requestId)
}

// required .CleanerChatType cleanerChatType = 2;
inline bool CleanerChatRequestMessage::_internal_has_cleanerchattype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CleanerChatRequestMessage::has_cleanerchattype() const {
  return _internal_has_cleanerchattype();
}
inline void CleanerChatRequestMessage::clear_cleanerchattype() {
  _impl_.cleanerchattype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::CleanerChatType CleanerChatRequestMessage::_internal_cleanerchattype() const {
  return static_cast< ::CleanerChatType >(_impl_.cleanerchattype_);
}
inline ::CleanerChatType CleanerChatRequestMessage::cleanerchattype() const {
  // @@protoc_insertion_point(field_get:CleanerChatRequestMessage.cleanerChatType)
  return _internal_cleanerchattype();
}
inline void CleanerChatRequestMessage::_internal_set_cleanerchattype(::CleanerChatType value) {
  assert(::CleanerChatType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cleanerchattype_ = value;
}
inline void CleanerChatRequestMessage::set_cleanerchattype(::CleanerChatType value) {
  _internal_set_cleanerchattype(value);
  // @@protoc_insertion_point(field_set:CleanerChatRequestMessage.cleanerChatType)
}

// optional uint32 gameId = 3 [default = 0];
inline bool CleanerChatRequestMessage::_internal_has_gameid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CleanerChatRequestMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void CleanerChatRequestMessage::clear_gameid() {
  _impl_.gameid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CleanerChatRequestMessage::_internal_gameid() const {
  return _impl_.gameid_;
}
inline uint32_t CleanerChatRequestMessage::gameid() const {
  // @@protoc_insertion_point(field_get:CleanerChatRequestMessage.gameId)
  return _internal_gameid();
}
inline void CleanerChatRequestMessage::_internal_set_gameid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.gameid_ = value;
}
inline void CleanerChatRequestMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:CleanerChatRequestMessage.gameId)
}

// required uint32 playerId = 4;
inline bool CleanerChatRequestMessage::_internal_has_playerid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CleanerChatRequestMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void CleanerChatRequestMessage::clear_playerid() {
  _impl_.playerid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CleanerChatRequestMessage::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t CleanerChatRequestMessage::playerid() const {
  // @@protoc_insertion_point(field_get:CleanerChatRequestMessage.playerId)
  return _internal_playerid();
}
inline void CleanerChatRequestMessage::_internal_set_playerid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.playerid_ = value;
}
inline void CleanerChatRequestMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:CleanerChatRequestMessage.playerId)
}

// required string playerName = 5;
inline bool CleanerChatRequestMessage::_internal_has_playername() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CleanerChatRequestMessage::has_playername() const {
  return _internal_has_playername();
}
inline void CleanerChatRequestMessage::clear_playername() {
  _impl_.playername_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CleanerChatRequestMessage::playername() const {
  // @@protoc_insertion_point(field_get:CleanerChatRequestMessage.playerName)
  return _internal_playername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CleanerChatRequestMessage::set_playername(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.playername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CleanerChatRequestMessage.playerName)
}
inline std::string* CleanerChatRequestMessage::mutable_playername() {
  std::string* _s = _internal_mutable_playername();
  // @@protoc_insertion_point(field_mutable:CleanerChatRequestMessage.playerName)
  return _s;
}
inline const std::string& CleanerChatRequestMessage::_internal_playername() const {
  return _impl_.playername_.Get();
}
inline void CleanerChatRequestMessage::_internal_set_playername(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.playername_.Set(value, GetArenaForAllocation());
}
inline std::string* CleanerChatRequestMessage::_internal_mutable_playername() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.playername_.Mutable(GetArenaForAllocation());
}
inline std::string* CleanerChatRequestMessage::release_playername() {
  // @@protoc_insertion_point(field_release:CleanerChatRequestMessage.playerName)
  if (!_internal_has_playername()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.playername_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playername_.IsDefault()) {
    _impl_.playername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CleanerChatRequestMessage::set_allocated_playername(std::string* playername) {
  if (playername != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.playername_.SetAllocated(playername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playername_.IsDefault()) {
    _impl_.playername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CleanerChatRequestMessage.playerName)
}

// required string chatMessage = 6;
inline bool CleanerChatRequestMessage::_internal_has_chatmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CleanerChatRequestMessage::has_chatmessage() const {
  return _internal_has_chatmessage();
}
inline void CleanerChatRequestMessage::clear_chatmessage() {
  _impl_.chatmessage_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CleanerChatRequestMessage::chatmessage() const {
  // @@protoc_insertion_point(field_get:CleanerChatRequestMessage.chatMessage)
  return _internal_chatmessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CleanerChatRequestMessage::set_chatmessage(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.chatmessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CleanerChatRequestMessage.chatMessage)
}
inline std::string* CleanerChatRequestMessage::mutable_chatmessage() {
  std::string* _s = _internal_mutable_chatmessage();
  // @@protoc_insertion_point(field_mutable:CleanerChatRequestMessage.chatMessage)
  return _s;
}
inline const std::string& CleanerChatRequestMessage::_internal_chatmessage() const {
  return _impl_.chatmessage_.Get();
}
inline void CleanerChatRequestMessage::_internal_set_chatmessage(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.chatmessage_.Set(value, GetArenaForAllocation());
}
inline std::string* CleanerChatRequestMessage::_internal_mutable_chatmessage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.chatmessage_.Mutable(GetArenaForAllocation());
}
inline std::string* CleanerChatRequestMessage::release_chatmessage() {
  // @@protoc_insertion_point(field_release:CleanerChatRequestMessage.chatMessage)
  if (!_internal_has_chatmessage()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.chatmessage_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chatmessage_.IsDefault()) {
    _impl_.chatmessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CleanerChatRequestMessage::set_allocated_chatmessage(std::string* chatmessage) {
  if (chatmessage != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.chatmessage_.SetAllocated(chatmessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chatmessage_.IsDefault()) {
    _impl_.chatmessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CleanerChatRequestMessage.chatMessage)
}

// -------------------------------------------------------------------

// CleanerChatReplyMessage

// required uint32 requestId = 1;
inline bool CleanerChatReplyMessage::_internal_has_requestid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CleanerChatReplyMessage::has_requestid() const {
  return _internal_has_requestid();
}
inline void CleanerChatReplyMessage::clear_requestid() {
  _impl_.requestid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CleanerChatReplyMessage::_internal_requestid() const {
  return _impl_.requestid_;
}
inline uint32_t CleanerChatReplyMessage::requestid() const {
  // @@protoc_insertion_point(field_get:CleanerChatReplyMessage.requestId)
  return _internal_requestid();
}
inline void CleanerChatReplyMessage::_internal_set_requestid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.requestid_ = value;
}
inline void CleanerChatReplyMessage::set_requestid(uint32_t value) {
  _internal_set_requestid(value);
  // @@protoc_insertion_point(field_set:CleanerChatReplyMessage.requestId)
}

// required .CleanerChatType cleanerChatType = 2;
inline bool CleanerChatReplyMessage::_internal_has_cleanerchattype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CleanerChatReplyMessage::has_cleanerchattype() const {
  return _internal_has_cleanerchattype();
}
inline void CleanerChatReplyMessage::clear_cleanerchattype() {
  _impl_.cleanerchattype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::CleanerChatType CleanerChatReplyMessage::_internal_cleanerchattype() const {
  return static_cast< ::CleanerChatType >(_impl_.cleanerchattype_);
}
inline ::CleanerChatType CleanerChatReplyMessage::cleanerchattype() const {
  // @@protoc_insertion_point(field_get:CleanerChatReplyMessage.cleanerChatType)
  return _internal_cleanerchattype();
}
inline void CleanerChatReplyMessage::_internal_set_cleanerchattype(::CleanerChatType value) {
  assert(::CleanerChatType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cleanerchattype_ = value;
}
inline void CleanerChatReplyMessage::set_cleanerchattype(::CleanerChatType value) {
  _internal_set_cleanerchattype(value);
  // @@protoc_insertion_point(field_set:CleanerChatReplyMessage.cleanerChatType)
}

// optional uint32 gameId = 3 [default = 0];
inline bool CleanerChatReplyMessage::_internal_has_gameid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CleanerChatReplyMessage::has_gameid() const {
  return _internal_has_gameid();
}
inline void CleanerChatReplyMessage::clear_gameid() {
  _impl_.gameid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CleanerChatReplyMessage::_internal_gameid() const {
  return _impl_.gameid_;
}
inline uint32_t CleanerChatReplyMessage::gameid() const {
  // @@protoc_insertion_point(field_get:CleanerChatReplyMessage.gameId)
  return _internal_gameid();
}
inline void CleanerChatReplyMessage::_internal_set_gameid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.gameid_ = value;
}
inline void CleanerChatReplyMessage::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:CleanerChatReplyMessage.gameId)
}

// required uint32 playerId = 4;
inline bool CleanerChatReplyMessage::_internal_has_playerid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CleanerChatReplyMessage::has_playerid() const {
  return _internal_has_playerid();
}
inline void CleanerChatReplyMessage::clear_playerid() {
  _impl_.playerid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CleanerChatReplyMessage::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t CleanerChatReplyMessage::playerid() const {
  // @@protoc_insertion_point(field_get:CleanerChatReplyMessage.playerId)
  return _internal_playerid();
}
inline void CleanerChatReplyMessage::_internal_set_playerid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.playerid_ = value;
}
inline void CleanerChatReplyMessage::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:CleanerChatReplyMessage.playerId)
}

// required .CleanerChatReplyMessage.CleanerActionType cleanerActionType = 5;
inline bool CleanerChatReplyMessage::_internal_has_cleaneractiontype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CleanerChatReplyMessage::has_cleaneractiontype() const {
  return _internal_has_cleaneractiontype();
}
inline void CleanerChatReplyMessage::clear_cleaneractiontype() {
  _impl_.cleaneractiontype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::CleanerChatReplyMessage_CleanerActionType CleanerChatReplyMessage::_internal_cleaneractiontype() const {
  return static_cast< ::CleanerChatReplyMessage_CleanerActionType >(_impl_.cleaneractiontype_);
}
inline ::CleanerChatReplyMessage_CleanerActionType CleanerChatReplyMessage::cleaneractiontype() const {
  // @@protoc_insertion_point(field_get:CleanerChatReplyMessage.cleanerActionType)
  return _internal_cleaneractiontype();
}
inline void CleanerChatReplyMessage::_internal_set_cleaneractiontype(::CleanerChatReplyMessage_CleanerActionType value) {
  assert(::CleanerChatReplyMessage_CleanerActionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.cleaneractiontype_ = value;
}
inline void CleanerChatReplyMessage::set_cleaneractiontype(::CleanerChatReplyMessage_CleanerActionType value) {
  _internal_set_cleaneractiontype(value);
  // @@protoc_insertion_point(field_set:CleanerChatReplyMessage.cleanerActionType)
}

// optional string cleanerText = 6 [default = ""];
inline bool CleanerChatReplyMessage::_internal_has_cleanertext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CleanerChatReplyMessage::has_cleanertext() const {
  return _internal_has_cleanertext();
}
inline void CleanerChatReplyMessage::clear_cleanertext() {
  _impl_.cleanertext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CleanerChatReplyMessage::cleanertext() const {
  // @@protoc_insertion_point(field_get:CleanerChatReplyMessage.cleanerText)
  return _internal_cleanertext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CleanerChatReplyMessage::set_cleanertext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.cleanertext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CleanerChatReplyMessage.cleanerText)
}
inline std::string* CleanerChatReplyMessage::mutable_cleanertext() {
  std::string* _s = _internal_mutable_cleanertext();
  // @@protoc_insertion_point(field_mutable:CleanerChatReplyMessage.cleanerText)
  return _s;
}
inline const std::string& CleanerChatReplyMessage::_internal_cleanertext() const {
  return _impl_.cleanertext_.Get();
}
inline void CleanerChatReplyMessage::_internal_set_cleanertext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cleanertext_.Set(value, GetArenaForAllocation());
}
inline std::string* CleanerChatReplyMessage::_internal_mutable_cleanertext() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cleanertext_.Mutable(GetArenaForAllocation());
}
inline std::string* CleanerChatReplyMessage::release_cleanertext() {
  // @@protoc_insertion_point(field_release:CleanerChatReplyMessage.cleanerText)
  if (!_internal_has_cleanertext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.cleanertext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cleanertext_.IsDefault()) {
    _impl_.cleanertext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CleanerChatReplyMessage::set_allocated_cleanertext(std::string* cleanertext) {
  if (cleanertext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cleanertext_.SetAllocated(cleanertext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cleanertext_.IsDefault()) {
    _impl_.cleanertext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CleanerChatReplyMessage.cleanerText)
}

// -------------------------------------------------------------------

// ChatCleanerMessage

// required .ChatCleanerMessage.ChatCleanerMessageType messageType = 1;
inline bool ChatCleanerMessage::_internal_has_messagetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ChatCleanerMessage::has_messagetype() const {
  return _internal_has_messagetype();
}
inline void ChatCleanerMessage::clear_messagetype() {
  _impl_.messagetype_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::ChatCleanerMessage_ChatCleanerMessageType ChatCleanerMessage::_internal_messagetype() const {
  return static_cast< ::ChatCleanerMessage_ChatCleanerMessageType >(_impl_.messagetype_);
}
inline ::ChatCleanerMessage_ChatCleanerMessageType ChatCleanerMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:ChatCleanerMessage.messageType)
  return _internal_messagetype();
}
inline void ChatCleanerMessage::_internal_set_messagetype(::ChatCleanerMessage_ChatCleanerMessageType value) {
  assert(::ChatCleanerMessage_ChatCleanerMessageType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.messagetype_ = value;
}
inline void ChatCleanerMessage::set_messagetype(::ChatCleanerMessage_ChatCleanerMessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:ChatCleanerMessage.messageType)
}

// optional .CleanerInitMessage cleanerInitMessage = 2;
inline bool ChatCleanerMessage::_internal_has_cleanerinitmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cleanerinitmessage_ != nullptr);
  return value;
}
inline bool ChatCleanerMessage::has_cleanerinitmessage() const {
  return _internal_has_cleanerinitmessage();
}
inline void ChatCleanerMessage::clear_cleanerinitmessage() {
  if (_impl_.cleanerinitmessage_ != nullptr) _impl_.cleanerinitmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CleanerInitMessage& ChatCleanerMessage::_internal_cleanerinitmessage() const {
  const ::CleanerInitMessage* p = _impl_.cleanerinitmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::CleanerInitMessage&>(
      ::_CleanerInitMessage_default_instance_);
}
inline const ::CleanerInitMessage& ChatCleanerMessage::cleanerinitmessage() const {
  // @@protoc_insertion_point(field_get:ChatCleanerMessage.cleanerInitMessage)
  return _internal_cleanerinitmessage();
}
inline void ChatCleanerMessage::unsafe_arena_set_allocated_cleanerinitmessage(
    ::CleanerInitMessage* cleanerinitmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cleanerinitmessage_);
  }
  _impl_.cleanerinitmessage_ = cleanerinitmessage;
  if (cleanerinitmessage) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChatCleanerMessage.cleanerInitMessage)
}
inline ::CleanerInitMessage* ChatCleanerMessage::release_cleanerinitmessage() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CleanerInitMessage* temp = _impl_.cleanerinitmessage_;
  _impl_.cleanerinitmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CleanerInitMessage* ChatCleanerMessage::unsafe_arena_release_cleanerinitmessage() {
  // @@protoc_insertion_point(field_release:ChatCleanerMessage.cleanerInitMessage)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CleanerInitMessage* temp = _impl_.cleanerinitmessage_;
  _impl_.cleanerinitmessage_ = nullptr;
  return temp;
}
inline ::CleanerInitMessage* ChatCleanerMessage::_internal_mutable_cleanerinitmessage() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cleanerinitmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::CleanerInitMessage>(GetArenaForAllocation());
    _impl_.cleanerinitmessage_ = p;
  }
  return _impl_.cleanerinitmessage_;
}
inline ::CleanerInitMessage* ChatCleanerMessage::mutable_cleanerinitmessage() {
  ::CleanerInitMessage* _msg = _internal_mutable_cleanerinitmessage();
  // @@protoc_insertion_point(field_mutable:ChatCleanerMessage.cleanerInitMessage)
  return _msg;
}
inline void ChatCleanerMessage::set_allocated_cleanerinitmessage(::CleanerInitMessage* cleanerinitmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cleanerinitmessage_;
  }
  if (cleanerinitmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cleanerinitmessage);
    if (message_arena != submessage_arena) {
      cleanerinitmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cleanerinitmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cleanerinitmessage_ = cleanerinitmessage;
  // @@protoc_insertion_point(field_set_allocated:ChatCleanerMessage.cleanerInitMessage)
}

// optional .CleanerInitAckMessage cleanerInitAckMessage = 3;
inline bool ChatCleanerMessage::_internal_has_cleanerinitackmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cleanerinitackmessage_ != nullptr);
  return value;
}
inline bool ChatCleanerMessage::has_cleanerinitackmessage() const {
  return _internal_has_cleanerinitackmessage();
}
inline void ChatCleanerMessage::clear_cleanerinitackmessage() {
  if (_impl_.cleanerinitackmessage_ != nullptr) _impl_.cleanerinitackmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::CleanerInitAckMessage& ChatCleanerMessage::_internal_cleanerinitackmessage() const {
  const ::CleanerInitAckMessage* p = _impl_.cleanerinitackmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::CleanerInitAckMessage&>(
      ::_CleanerInitAckMessage_default_instance_);
}
inline const ::CleanerInitAckMessage& ChatCleanerMessage::cleanerinitackmessage() const {
  // @@protoc_insertion_point(field_get:ChatCleanerMessage.cleanerInitAckMessage)
  return _internal_cleanerinitackmessage();
}
inline void ChatCleanerMessage::unsafe_arena_set_allocated_cleanerinitackmessage(
    ::CleanerInitAckMessage* cleanerinitackmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cleanerinitackmessage_);
  }
  _impl_.cleanerinitackmessage_ = cleanerinitackmessage;
  if (cleanerinitackmessage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChatCleanerMessage.cleanerInitAckMessage)
}
inline ::CleanerInitAckMessage* ChatCleanerMessage::release_cleanerinitackmessage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CleanerInitAckMessage* temp = _impl_.cleanerinitackmessage_;
  _impl_.cleanerinitackmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CleanerInitAckMessage* ChatCleanerMessage::unsafe_arena_release_cleanerinitackmessage() {
  // @@protoc_insertion_point(field_release:ChatCleanerMessage.cleanerInitAckMessage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CleanerInitAckMessage* temp = _impl_.cleanerinitackmessage_;
  _impl_.cleanerinitackmessage_ = nullptr;
  return temp;
}
inline ::CleanerInitAckMessage* ChatCleanerMessage::_internal_mutable_cleanerinitackmessage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cleanerinitackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::CleanerInitAckMessage>(GetArenaForAllocation());
    _impl_.cleanerinitackmessage_ = p;
  }
  return _impl_.cleanerinitackmessage_;
}
inline ::CleanerInitAckMessage* ChatCleanerMessage::mutable_cleanerinitackmessage() {
  ::CleanerInitAckMessage* _msg = _internal_mutable_cleanerinitackmessage();
  // @@protoc_insertion_point(field_mutable:ChatCleanerMessage.cleanerInitAckMessage)
  return _msg;
}
inline void ChatCleanerMessage::set_allocated_cleanerinitackmessage(::CleanerInitAckMessage* cleanerinitackmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cleanerinitackmessage_;
  }
  if (cleanerinitackmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cleanerinitackmessage);
    if (message_arena != submessage_arena) {
      cleanerinitackmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cleanerinitackmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cleanerinitackmessage_ = cleanerinitackmessage;
  // @@protoc_insertion_point(field_set_allocated:ChatCleanerMessage.cleanerInitAckMessage)
}

// optional .CleanerChatRequestMessage cleanerChatRequestMessage = 4;
inline bool ChatCleanerMessage::_internal_has_cleanerchatrequestmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cleanerchatrequestmessage_ != nullptr);
  return value;
}
inline bool ChatCleanerMessage::has_cleanerchatrequestmessage() const {
  return _internal_has_cleanerchatrequestmessage();
}
inline void ChatCleanerMessage::clear_cleanerchatrequestmessage() {
  if (_impl_.cleanerchatrequestmessage_ != nullptr) _impl_.cleanerchatrequestmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::CleanerChatRequestMessage& ChatCleanerMessage::_internal_cleanerchatrequestmessage() const {
  const ::CleanerChatRequestMessage* p = _impl_.cleanerchatrequestmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::CleanerChatRequestMessage&>(
      ::_CleanerChatRequestMessage_default_instance_);
}
inline const ::CleanerChatRequestMessage& ChatCleanerMessage::cleanerchatrequestmessage() const {
  // @@protoc_insertion_point(field_get:ChatCleanerMessage.cleanerChatRequestMessage)
  return _internal_cleanerchatrequestmessage();
}
inline void ChatCleanerMessage::unsafe_arena_set_allocated_cleanerchatrequestmessage(
    ::CleanerChatRequestMessage* cleanerchatrequestmessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cleanerchatrequestmessage_);
  }
  _impl_.cleanerchatrequestmessage_ = cleanerchatrequestmessage;
  if (cleanerchatrequestmessage) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChatCleanerMessage.cleanerChatRequestMessage)
}
inline ::CleanerChatRequestMessage* ChatCleanerMessage::release_cleanerchatrequestmessage() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CleanerChatRequestMessage* temp = _impl_.cleanerchatrequestmessage_;
  _impl_.cleanerchatrequestmessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CleanerChatRequestMessage* ChatCleanerMessage::unsafe_arena_release_cleanerchatrequestmessage() {
  // @@protoc_insertion_point(field_release:ChatCleanerMessage.cleanerChatRequestMessage)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CleanerChatRequestMessage* temp = _impl_.cleanerchatrequestmessage_;
  _impl_.cleanerchatrequestmessage_ = nullptr;
  return temp;
}
inline ::CleanerChatRequestMessage* ChatCleanerMessage::_internal_mutable_cleanerchatrequestmessage() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.cleanerchatrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::CleanerChatRequestMessage>(GetArenaForAllocation());
    _impl_.cleanerchatrequestmessage_ = p;
  }
  return _impl_.cleanerchatrequestmessage_;
}
inline ::CleanerChatRequestMessage* ChatCleanerMessage::mutable_cleanerchatrequestmessage() {
  ::CleanerChatRequestMessage* _msg = _internal_mutable_cleanerchatrequestmessage();
  // @@protoc_insertion_point(field_mutable:ChatCleanerMessage.cleanerChatRequestMessage)
  return _msg;
}
inline void ChatCleanerMessage::set_allocated_cleanerchatrequestmessage(::CleanerChatRequestMessage* cleanerchatrequestmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cleanerchatrequestmessage_;
  }
  if (cleanerchatrequestmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cleanerchatrequestmessage);
    if (message_arena != submessage_arena) {
      cleanerchatrequestmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cleanerchatrequestmessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.cleanerchatrequestmessage_ = cleanerchatrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:ChatCleanerMessage.cleanerChatRequestMessage)
}

// optional .CleanerChatReplyMessage cleanerChatReplyMessage = 5;
inline bool ChatCleanerMessage::_internal_has_cleanerchatreplymessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cleanerchatreplymessage_ != nullptr);
  return value;
}
inline bool ChatCleanerMessage::has_cleanerchatreplymessage() const {
  return _internal_has_cleanerchatreplymessage();
}
inline void ChatCleanerMessage::clear_cleanerchatreplymessage() {
  if (_impl_.cleanerchatreplymessage_ != nullptr) _impl_.cleanerchatreplymessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::CleanerChatReplyMessage& ChatCleanerMessage::_internal_cleanerchatreplymessage() const {
  const ::CleanerChatReplyMessage* p = _impl_.cleanerchatreplymessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::CleanerChatReplyMessage&>(
      ::_CleanerChatReplyMessage_default_instance_);
}
inline const ::CleanerChatReplyMessage& ChatCleanerMessage::cleanerchatreplymessage() const {
  // @@protoc_insertion_point(field_get:ChatCleanerMessage.cleanerChatReplyMessage)
  return _internal_cleanerchatreplymessage();
}
inline void ChatCleanerMessage::unsafe_arena_set_allocated_cleanerchatreplymessage(
    ::CleanerChatReplyMessage* cleanerchatreplymessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cleanerchatreplymessage_);
  }
  _impl_.cleanerchatreplymessage_ = cleanerchatreplymessage;
  if (cleanerchatreplymessage) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChatCleanerMessage.cleanerChatReplyMessage)
}
inline ::CleanerChatReplyMessage* ChatCleanerMessage::release_cleanerchatreplymessage() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CleanerChatReplyMessage* temp = _impl_.cleanerchatreplymessage_;
  _impl_.cleanerchatreplymessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CleanerChatReplyMessage* ChatCleanerMessage::unsafe_arena_release_cleanerchatreplymessage() {
  // @@protoc_insertion_point(field_release:ChatCleanerMessage.cleanerChatReplyMessage)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CleanerChatReplyMessage* temp = _impl_.cleanerchatreplymessage_;
  _impl_.cleanerchatreplymessage_ = nullptr;
  return temp;
}
inline ::CleanerChatReplyMessage* ChatCleanerMessage::_internal_mutable_cleanerchatreplymessage() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.cleanerchatreplymessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::CleanerChatReplyMessage>(GetArenaForAllocation());
    _impl_.cleanerchatreplymessage_ = p;
  }
  return _impl_.cleanerchatreplymessage_;
}
inline ::CleanerChatReplyMessage* ChatCleanerMessage::mutable_cleanerchatreplymessage() {
  ::CleanerChatReplyMessage* _msg = _internal_mutable_cleanerchatreplymessage();
  // @@protoc_insertion_point(field_mutable:ChatCleanerMessage.cleanerChatReplyMessage)
  return _msg;
}
inline void ChatCleanerMessage::set_allocated_cleanerchatreplymessage(::CleanerChatReplyMessage* cleanerchatreplymessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cleanerchatreplymessage_;
  }
  if (cleanerchatreplymessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cleanerchatreplymessage);
    if (message_arena != submessage_arena) {
      cleanerchatreplymessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cleanerchatreplymessage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.cleanerchatreplymessage_ = cleanerchatreplymessage;
  // @@protoc_insertion_point(field_set_allocated:ChatCleanerMessage.cleanerChatReplyMessage)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CleanerChatReplyMessage_CleanerActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CleanerChatReplyMessage_CleanerActionType>() {
  return ::CleanerChatReplyMessage_CleanerActionType_descriptor();
}
template <> struct is_proto_enum< ::ChatCleanerMessage_ChatCleanerMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChatCleanerMessage_ChatCleanerMessageType>() {
  return ::ChatCleanerMessage_ChatCleanerMessageType_descriptor();
}
template <> struct is_proto_enum< ::CleanerChatType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CleanerChatType>() {
  return ::CleanerChatType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chatcleaner_2eproto
